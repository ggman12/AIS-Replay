'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var xmlbuilder = require('xmlbuilder');

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

class XMLCreator {
  constructor(settings) {
    if (settings === void 0) {
      settings = {};
    }

    _defineProperty(this, "settings", void 0);

    this.settings = settings;
  } // eslint-disable-next-line complexity


  processXmlItem(dir, key, value) {
    if (key === 'attributes') {
      Object.keys(value).forEach(attribute => {
        dir.attribute(attribute, value[attribute]);
      });
      return;
    }

    if (key === 'email') {
      const email = value.split('@');
      dir.ele(key, {
        id: email[0],
        domain: email[1]
      });
      return;
    }

    if (value instanceof Date) {
      dir.ele(key, value.toISOString());
      return;
    }

    if (Array.isArray(value) && typeof value[0] === 'object') {
      value.forEach(item => {
        this.generateXmlData(dir.ele(key), item);
      });
      return;
    }

    if (Array.isArray(value)) {
      dir.ele(key, value.join(','));
      return;
    }

    if (typeof value === 'object') {
      this.generateXmlData(dir.ele(key), value);
      return;
    }

    dir.ele(key, value);
  }

  generateXmlData(dir, object) {
    Object.keys(object).map(key => {
      return {
        key,
        value: object[key]
      };
    }).forEach((_ref) => {
      let key = _ref.key,
          value = _ref.value;
      this.processXmlItem(dir, key, value);
    });
  }

  toString(data) {
    const root = xmlbuilder.create('gpx', {
      encoding: 'UTF-8'
    });
    this.generateXmlData(root, data);
    return root.end(_objectSpread({
      allowEmpty: true,
      indent: '  ',
      newline: '\n',
      pretty: true
    }, this.settings));
  }

}

exports.XMLCreator = XMLCreator;
