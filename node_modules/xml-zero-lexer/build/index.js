"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var NodeTypes = exports.NodeTypes = {
  XML_DECLARATION: 0, // unofficial
  // Most XML parsers ignore this but because I'm parsing it I may as well include it.
  // At least it lets you know if there were multiple declarations.
  //
  // Also inserting it here makes Object.keys(NodeTypes) array indexes line up with values!
  // E.g. Object.keys(NodeTypes)[0] === NodeTypes.XML_DECLARATION
  // (Strictly speaking map keys are unordered but in practice they are, and we don't rely on it)
  ELEMENT_NODE: 1,
  ATTRIBUTE_NODE: 2,
  TEXT_NODE: 3, // Note that these can include entities which should be resolved before display
  CDATA_SECTION_NODE: 4,
  ENTITY_REFERENCE_NODE: 5, // Not used
  //
  // After a lot of thought I've decided that entities shouldn't be resolved in the Lexer,
  //
  // Instead entities are just ignored and are stored as-is as part of the node because:
  // (1) We only support entities that resolve to characters, we don't support crufty
  //     complicated entities that insert elements, so there's no actual structural need to
  //     do it.
  // (2) It simplifies the code and data structures, and it shrinks data structure memory usage.
  //     E.g. Text doesn't need to switch between TEXT_NODE and ENTITY_REFERENCE_NODE.
  // (3) They can be resolved later using a utility function. E.g. have a .textContent() on
  //     nodes that resolves it. This approach would probably result in less memory use.
  // (4) It's slightly against style of zero-copy because we'd need to make new strings
  //     to resolve the entities. Not a difficult job but again it's unnecessary memory use.
  //
  //  So I've decided that's not the job of this lexer.
  //
  ENTITY_NODE: 6, // Only supported as <!ENTITY ...> outside of <!DOCTYPE ...>
  // E.g. <!DOCTYPE [ <!ENTITY> ]> will just be a string inside DOCTYPE and not an ENTITY_NODE.
  PROCESSING_INSTRUCTION_NODE: 7,
  COMMENT_NODE: 8,
  DOCUMENT_NODE: 9, // Not used. Root elements are just elements.
  DOCUMENT_TYPE_NODE: 10,
  DOCUMENT_FRAGMENT_NODE: 11, // Don't support this either
  NOTATION_NODE: 12,
  CLOSE_ELEMENT: 13, // unofficial
  JSX_ATTRIBUTE: 14, // unofficial
  JSX: 15 // unofficial
};

var NodeTypeKeys = exports.NodeTypeKeys = Object.keys(NodeTypes).sort(function (a, b) {
  return NodeTypes[a] - NodeTypes[b];
});

var WHITESPACE = [" ", "\r", "\n", "\t"];

var QUOTES = ['"', "'"];

var ALL_QUOTES = ["`"].concat(QUOTES);

var JS_OPEN_NESTING = ["{", "("];
var JS_END_NESTING = ["}", ")"];
var JS_ESCAPE_STRING = "\\";
var JS_COMMENT = "//";
var JS_MULTILINE_COMMENT = ["/*", "*/"];
var LINE_BREAKS = ["\n", "\r"];
var JS_TEMPLATE_STRING = "`";
var JS_TEMPLATE_STRING_EXPRESSION = ["${", "}"];
var JSX_INLINE = ["{", "}"];

var seekNotChar = function seekNotChar(xml, i, searchChars) {
  while (searchChars.indexOf(xml[i]) !== -1) {
    i++;
    if (i > xml.length) throw Error("Error lexing XML. Unterminated node.");
  }
  return i;
};

var seekChar = function seekChar(xml, i, searchChars) {
  while (searchChars.indexOf(xml[i]) === -1) {
    i++;
    if (i > xml.length) return i;
  }
  return i;
};

var seekString = function seekString(xml, i, searchString) {
  i = xml.indexOf(searchString, i);
  if (i === -1) i = xml.length;
  return i;
};

var seekJSExpression = function seekJSExpression(xml, i) {
  var nesting = 1;
  var JS_TOKENS = [].concat(JS_OPEN_NESTING, JS_END_NESTING, _toConsumableArray(ALL_QUOTES), [JS_COMMENT[0], JS_MULTILINE_COMMENT[0][0]]);

  var exitAfter = 1000000; // At least 10MB of tokens
  while (nesting > 0 && i < xml.length) {
    i++;
    i = seekChar(xml, i, JS_TOKENS);
    var char = xml[i];
    if (ALL_QUOTES.indexOf(char) !== -1) {
      i++;
      while (xml[i] !== char) {
        if (char === JS_TEMPLATE_STRING) {
          i = Math.min(seekChar(xml, i, [char, JS_ESCAPE_STRING]), seekString(xml, i, JS_TEMPLATE_STRING_EXPRESSION[0]));
          if (xml.substring(i, i + JS_TEMPLATE_STRING_EXPRESSION[0].length) === JS_TEMPLATE_STRING_EXPRESSION[0]) {
            i++;
            i = seekJSExpression(xml, i);
          }
        } else {
          i = seekChar(xml, i, [char, JS_ESCAPE_STRING].concat(LINE_BREAKS));
        }
        if (xml[i] === JS_ESCAPE_STRING) {
          i += 2; // can escapes ever be longer?
        } else if (char !== JS_TEMPLATE_STRING && LINE_BREAKS.indexOf(xml[i]) !== -1) {
          i++;
          break; // just exit
        }
        exitAfter--;
        if (exitAfter === 0) throw Error("Exiting after too many loops");
      }
      i++; // past closing character
    } else if (xml.substring(i, i + JS_COMMENT.length) === JS_COMMENT) {
      i = seekChar(xml, i, LINE_BREAKS);
      i++;
    } else if (xml.substring(i, i + JS_MULTILINE_COMMENT[0].length) === JS_MULTILINE_COMMENT[0]) {
      i = seekString(xml, i, JS_MULTILINE_COMMENT[1]);
      i++;
    } else if (JS_END_NESTING.indexOf(char) !== -1) {
      nesting--;
    } else if (JS_OPEN_NESTING.indexOf(char) !== -1) {
      nesting++;
    }
    exitAfter--;
    if (exitAfter === 0) throw Error("Exiting after too many loops");
  }
  return i;
};

var onQuestionElement = exports.onQuestionElement = function onQuestionElement(xml, i, mode) {
  i++;
  var token = [NodeTypes.PROCESSING_INSTRUCTION_NODE, i];
  i = seekChar(xml, i, [">", "?"].concat(WHITESPACE));
  if (xml[i] === ">" && xml[i - 1] === "/") {
    i--;
  }
  token.push(i);

  if (xml.substring(token[1], token[2]) === "xml") {
    // it's actually an XML declaration
    token[0] = NodeTypes.XML_DECLARATION;
  }
  i = seekNotChar(xml, i, ["?", ">"].concat(WHITESPACE));
  if (xml[i] === "?") i++;

  return [i, WHITESPACE.indexOf(xml[i]) === -1, token];
};

var onAttribute = exports.onAttribute = function onAttribute(xml, i, inElement) {
  var token = [NodeTypes.ATTRIBUTE_NODE];
  if (QUOTES.indexOf(xml[i]) !== -1) {
    // attribute with quoted name
    i++;
    token.push(i);
    i = seekChar(xml, i, [xml[token[1] - 1]]);
    token.push(i); // end of attribute name
    i++; // skip quote
  } else if (xml[i] === "[" && WHITESPACE.indexOf(xml[i + 1]) !== -1) {
    token.push(i);
    i = seekString(xml, i, "]>");
    i += 1;
    token.push(i); // end of attribute name
  } else if (xml[i] === "{") {
    token.pop(); // scrub default attribute
    token.push(NodeTypes.JSX_ATTRIBUTE);
    i++;
    token.push(i);
    i--;
    i = seekJSExpression(xml, i);
    token.push(i);
    i++;
  } else {
    token.push(i);
    i = seekChar(xml, i, ["=", "/", ">"].concat(WHITESPACE));
    token.push(i); // end of attribute name
  }

  // valueless attribute at the end of element so exit early
  if (xml[i] === ">") {
    if (xml[i - 1] === "?") {
      token[2]--;
    }
    i++;
    return [i, false, token];
  } else if (xml[i] === "/" && xml[i + 1] === ">") {
    return [i, true, token];
  }

  var notWhitespace = seekNotChar(xml, i, WHITESPACE);
  if (xml[notWhitespace] !== "=") {
    return [i, inElement, token];
  }
  i = notWhitespace + 1;
  var enclosed = seekNotChar(xml, i, WHITESPACE);
  var hasQuotes = QUOTES.indexOf(xml[i]) !== -1;
  // console.log("enclosed?", enclosed);
  if (hasQuotes) {
    // surrounded by quotes
    i++;
    token.push(i);
    i++;
    i = seekChar(xml, i, xml[enclosed]);
    token.push(i);
    i++;
  } else if (xml[i] === "{") {
    // JSX attribute
    token[0] = NodeTypes.JSX_ATTRIBUTE;
    i++;
    token.push(i);
    i--;
    i = seekJSExpression(xml, i);
    token.push(i);
    i++;
  } else {
    // not surrounded by quotes
    token.push(i);
    i = seekChar(xml, i, [">"].concat(WHITESPACE));
    if (xml[i] === ">" && xml[i - 1] === "?") {
      i--;
    }
    token.push(i);
  }

  i = seekNotChar(xml, i, WHITESPACE);
  return [i, true, token];
};

var onEndTag = exports.onEndTag = function onEndTag(xml, i, inElement) {
  if (xml[i] === "?") {
    i++;
  }
  i++;
  return [i, false];
};

var onClose = exports.onClose = function onClose(xml, i, inElement) {
  // console.log("onClose, starting... ", xml[i], "from", xml);
  var token = [NodeTypes.CLOSE_ELEMENT];
  i = seekChar(xml, i, [">"].concat(WHITESPACE));
  i++;
  return [i, false, token];
};

var onElement = exports.onElement = function onElement(xml, i, inElement) {
  var token = [NodeTypes.ELEMENT_NODE, i];
  i = seekChar(xml, i, [">", "/"].concat(WHITESPACE));

  if (token[1] === i) {
    // element was nameless "<>" or "<    attr>" or "< />"
    // element without a name
    token.pop();
    return [i, true, token];
  }

  token.push(i);
  return [i, true, token];
};

var onExclamation = exports.onExclamation = function onExclamation(xml, i, inElement) {
  var token = [];
  if (xml.substring(i, i + 3) === "!--") {
    // maybe this should be the default assumption?
    token.push(NodeTypes.COMMENT_NODE, i + 3);
    i = seekString(xml, i, "-->");
    token.push(i);
    i += 3;
    inElement = false;
  } else if (xml.substring(i, i + 8) === "!DOCTYPE") {
    i += 8;
    token.push(NodeTypes.DOCUMENT_TYPE_NODE);
  } else if (xml.substring(i, i + 8) === "![CDATA[") {
    i += 8;
    token.push(NodeTypes.CDATA_SECTION_NODE, i);
    i = seekString(xml, i, "]]>");
    token.push(i);
    i += 3;
    inElement = false;
  } else if (xml.substring(i, i + 7) === "!ENTITY") {
    i += 7;
    token.push(NodeTypes.ENTITY_NODE);
  } else if (xml.substring(i, i + 9) === "!NOTATION") {
    i += 9;
    token.push(NodeTypes.NOTATION_NODE);
  }
  return [i, inElement, token];
};

var onShorthandCDATA = exports.onShorthandCDATA = function onShorthandCDATA(xml, i, inElement) {
  var token = [];
  i += 1;
  token.push(NodeTypes.CDATA_SECTION_NODE, i);
  i = seekString(xml, i, "]>");
  token.push(i);
  i += 2;
  inElement = false;
  return [i, inElement, token];
};

var onText = exports.onText = function onText(xml, i) {
  var jsx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var tokens = [];
  var token = [NodeTypes.TEXT_NODE, i];
  var chars = ["<"];
  if (jsx) chars.push(JSX_INLINE[0]);
  i = seekChar(xml, i, chars);

  if (token[1] === i && xml[i] === JSX_INLINE[0]) {
    i++;
    token[0] = NodeTypes.JSX;
    token[1] = i;
    i = seekJSExpression(xml, i);
    token.push(i);
    i++;
  } else {
    token.push(i);
  }

  return [i, false, token];
};

var onBlackhole = exports.onBlackhole = function onBlackhole(xml, i, inElement, untilToken) {
  var token = [NodeTypes.TEXT_NODE, i];
  var closingTag = "</" + xml.substring(untilToken[1], untilToken[2]);
  i = seekString(xml, i, closingTag);
  token.push(i);
  return [i, true, token];
};

var HTML_SELF_CLOSING_ELEMENTS = ["area", "base", "br", "col", "hr", "img", "input", "link", "meta", "param", "command", "keygen", "source"];

var onHTMLSelfClosingElement = function onHTMLSelfClosingElement(xml, tokens) {
  var token = findLastNodeType(tokens, NodeTypes.ELEMENT_NODE);
  if (token && token.length > 2) {
    var tagName = xml.substring(token[1], token[2]).toLowerCase(); // lowercase because HTML elements are case-insensitive
    if (HTML_SELF_CLOSING_ELEMENTS.indexOf(tagName) !== -1) {
      return [NodeTypes.CLOSE_ELEMENT];
    }
  }
};

var findLastNodeType = function findLastNodeType(tokens, nodeType) {
  for (var i = tokens.length - 1; i >= 0; --i) {
    if (tokens[i][0] === nodeType) return tokens[i];
  }
};

var defaultBlackholes = ["script", "style"];

var defaultOptions = {
  blackholes: defaultBlackholes,
  jsx: false,
  html: false
};

// his divine shadow
var Lexx = function Lexx(xml, options) {
  var useOptions = _extends({}, defaultOptions, options);

  var tokens = [];
  var i = 0; // Number.MAX_SAFE_INTEGER is 9007199254740991 so that's 9007199 gigabytes of string and using integers makes sense
  var char = void 0;
  var token = void 0;
  var textTokens = void 0;
  var debugExitAfterLoops = Math.min(xml.length, 1073741824); // an arbitrary large number
  var inElement = false;

  while (i < xml.length) {
    char = xml[i];
    debugExitAfterLoops--;
    if (debugExitAfterLoops < 0) throw Error("Congratulations, you probably found a bug in xml-zero-lexer! Please raise an issue on https://github.com/holloway/xml-zero.js/issues with your XML, which was: " + xml);

    if (!inElement) {
      // text node
      if (char !== "<") {
        var _onText = onText(xml, i, useOptions.jsx);

        var _onText2 = _slicedToArray(_onText, 3);

        i = _onText2[0];
        inElement = _onText2[1];
        token = _onText2[2];

        tokens.push(token);
      } else {
        // element starts again
        inElement = true;
      }
    }
    // don't join with above `if` to make this an `else if` because in above `inElement` can be set `true`
    if (inElement) {
      switch (char) {
        case "<":
          i++;
          char = xml[i];
          switch (char) {
            case "/":
              inElement = false;
              if (xml[i + 1] === ">") {
                var _onElement = onElement(xml, i, inElement);

                var _onElement2 = _slicedToArray(_onElement, 3);

                i = _onElement2[0];
                inElement = _onElement2[1];
                token = _onElement2[2];

                tokens.push(token);
              }

              var _onClose = onClose(xml, i, inElement);

              var _onClose2 = _slicedToArray(_onClose, 3);

              i = _onClose2[0];
              inElement = _onClose2[1];
              token = _onClose2[2];

              tokens.push(token);
              break;
            case "?":
              var _onQuestionElement = onQuestionElement(xml, i, inElement);

              var _onQuestionElement2 = _slicedToArray(_onQuestionElement, 3);

              i = _onQuestionElement2[0];
              inElement = _onQuestionElement2[1];
              token = _onQuestionElement2[2];

              tokens.push(token);
              break;
            case "!":
              var _onExclamation = onExclamation(xml, i, inElement);

              var _onExclamation2 = _slicedToArray(_onExclamation, 3);

              i = _onExclamation2[0];
              inElement = _onExclamation2[1];
              token = _onExclamation2[2];

              tokens.push(token);
              break;
            case "[":
              var _onShorthandCDATA = onShorthandCDATA(xml, i, inElement);

              var _onShorthandCDATA2 = _slicedToArray(_onShorthandCDATA, 3);

              i = _onShorthandCDATA2[0];
              inElement = _onShorthandCDATA2[1];
              token = _onShorthandCDATA2[2];

              tokens.push(token);
              break;
            case ">":
              var _onElement3 = onElement(xml, i, inElement);

              var _onElement4 = _slicedToArray(_onElement3, 3);

              i = _onElement4[0];
              inElement = _onElement4[1];
              token = _onElement4[2];

              tokens.push(token);

              break;
            default:
              var _onElement5 = onElement(xml, i, inElement);

              var _onElement6 = _slicedToArray(_onElement5, 3);

              i = _onElement6[0];
              inElement = _onElement6[1];
              token = _onElement6[2];

              tokens.push(token);
              break;
          }
          break;
        case "/":
          if (xml[i + 1] === ">") {
            inElement = false;

            var _onClose3 = onClose(xml, i, inElement);

            var _onClose4 = _slicedToArray(_onClose3, 3);

            i = _onClose4[0];
            inElement = _onClose4[1];
            token = _onClose4[2];

            tokens.push(token);
          } else {
            // in an element finding a "/" between attributes but not at end. weird. ignore.
            i++;
          }
          break;
        case "?":
        case ">":
          var _onEndTag = onEndTag(xml, i);

          var _onEndTag2 = _slicedToArray(_onEndTag, 2);

          i = _onEndTag2[0];
          inElement = _onEndTag2[1];

          var lastElement = findLastNodeType(tokens, NodeTypes.ELEMENT_NODE);
          if (lastElement && useOptions.blackholes.indexOf(xml.substring(lastElement[1], lastElement[2])) !== -1) {
            var _onBlackhole = onBlackhole(xml, i, inElement, lastElement);

            var _onBlackhole2 = _slicedToArray(_onBlackhole, 3);

            i = _onBlackhole2[0];
            inElement = _onBlackhole2[1];
            token = _onBlackhole2[2];

            tokens.push(token);
          }
          if (useOptions.html) {
            token = onHTMLSelfClosingElement(xml, tokens);
            if (token) {
              tokens.push(token);
            }
          }
          break;
        case " ":
        case "\t":
        case "\r":
        case "\n":
          // ignore whitespace inside element between attributes or before end
          i++;
          break;
        default:
          var _onAttribute = onAttribute(xml, i, inElement);

          var _onAttribute2 = _slicedToArray(_onAttribute, 3);

          i = _onAttribute2[0];
          inElement = _onAttribute2[1];
          token = _onAttribute2[2];

          tokens.push(token);
          if (!inElement && useOptions.html) {
            token = onHTMLSelfClosingElement(xml, tokens);
            if (token) {
              tokens.push(token);
            }
          }
          break;
      }
    }
  }
  return tokens;
};

exports.default = Lexx;